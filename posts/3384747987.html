<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JS的异步解决方案 | Nightwishのblog🧊</title><meta name="keywords" content="JS,Promsie、Async、await"><meta name="author" content="飞儿"><meta name="copyright" content="飞儿"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前端异步之路"><meta property="og:type" content="article"><meta property="og:title" content="JS的异步解决方案"><meta property="og:url" content="https://mynightwish.online/posts/3384747987.html"><meta property="og:site_name" content="Nightwishのblog🧊"><meta property="og:description" content="前端异步之路"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTfnIl0f3oUJLgGFb7Qgi97y1hY9uIQsHizXQ&usqp=CAU"><meta property="article:published_time" content="2021-12-11T12:41:16.000Z"><meta property="article:modified_time" content="2023-01-17T11:47:30.974Z"><meta property="article:author" content="飞儿"><meta property="article:tag" content="JS"><meta property="article:tag" content="Promsie、Async、await"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTfnIl0f3oUJLgGFb7Qgi97y1hY9uIQsHizXQ&usqp=CAU"><link rel="shortcut icon" href="https://mynightwish.oss-cn-beijing.aliyuncs.com/React/雪人.webp"><link rel="canonical" href="https://mynightwish.online/posts/3384747987"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!1,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"/",css:"/"},fancybox:{js:"/",css:"/"}},isPhotoFigcaption:!1,islazyload:!0,isanchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"JS的异步解决方案",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-01-17 19:47:30"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const n=()=>{GLOBAL_CONFIG_SITE.isHome&&/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")};n(),document.addEventListener("pjax:complete",n)})(window)</script><link rel="stylesheet" href="/css/custom.css" media="async" onload='this.media="all"'><link rel="stylesheet" href="/css/double.css" media="async" onload='this.media="all"'><link rel="stylesheet" href="//at.alicdn.com/t/c/font_3859043_rw1ayonelb.css"><style id="rightSide"></style><style id="themeColor"></style><style id="defineBg"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><link rel="stylesheet" href="/css/universe.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/lastLoad.css" media="async" onload='this.media="all"'><svg aria-hidden="true" style="position:absolute;overflow:hidden;width:0;height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload='this.media="all"'><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"><style>#web_bg{background:var(--default-bg);background-attachment:local;background-position:center;background-size:cover;background-repeat:no-repeat}[data-theme=dark] #web_bg{background:var(--darkmode-bg)!important;background-attachment:local!important;background-position:center!important;background-size:cover!important;background-repeat:no-repeat!important}</style></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://mynightwish.oss-cn-beijing.aliyuncs.com/React/avartor.webp" onerror='onerror=null,src="https://mynightwish.oss-cn-beijing.aliyuncs.com/staticResource/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">112</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">91</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-food-strawberry"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-food-strawberry"></use></svg><span>首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-food-eggyolkcake"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-food-eggyolkcake"></use></svg><span>分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-food-popsicle"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-food-popsicle"></use></svg><span>时间轴</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-food-doughnut"></use></svg><span>足迹</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/charts/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xiangjiB"></use></svg><span>文章</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-diannaoB"></use></svg><span>媒体</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-erjiB"></use></svg><span>音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/movies/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-dianshijiB"></use></svg><span>视频</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/books/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shouyinjiB"></use></svg><span>书籍</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-food-macaron"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-food-macaron"></use></svg><span>留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTfnIl0f3oUJLgGFb7Qgi97y1hY9uIQsHizXQ&amp;usqp=CAU)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Nightwishのblog🧊</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><i class="fa-fw icon-food-strawberry"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-food-strawberry"></use></svg><span>首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><i class="fa-fw icon-food-eggyolkcake"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-food-eggyolkcake"></use></svg><span>分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><i class="fa-fw icon-food-popsicle"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-food-popsicle"></use></svg><span>时间轴</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-food-doughnut"></use></svg><span>足迹</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/charts/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-xiangjiB"></use></svg><span>文章</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-diannaoB"></use></svg><span>媒体</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-erjiB"></use></svg><span>音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/movies/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-dianshijiB"></use></svg><span>视频</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/books/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shouyinjiB"></use></svg><span>书籍</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><i class="fa-fw icon-food-macaron"></i><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-food-macaron"></use></svg><span>留言板</span></a></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()"></a></center><div id="nav-right"><div id="search-button"><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:28px;width:28px;fill:currentColor;position:relative" aria-hidden="true"><use xlink:href="#icon-sousuo"></use></svg><span>search.title</span></a></div><a class="meihua faa-parent animated-hover" onclick="toggleWinbox()" title="美化设置-自定义你的风格" id="meihua-button"><svg class="faa-tada icon" style="height:28px;width:28px;fill:currentColor;position:relative;margin-left:25px;margin-right:25px" aria-hidden="true"><use xlink:href="#icon-food-cookie"></use></svg></a><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:28px;width:28px;fill:currentColor;position:relative" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-xiuxi"></use></svg></a><div id="toggle-menu"><a><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">JS的异步解决方案</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-11T12:41:16.000Z" title="发表于 2021-12-11 20:41:16">2021-12-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-17T11:47:30.974Z" title="更新于 2023-01-17 19:47:30">2023-01-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/1-2-JS/">1.2-JS</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">1.1w</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>45分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="JS的异步解决方案"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="异步解决方案">异步解决方案<a class="anchor" href="#异步解决方案">·</a></h2><h3 id="1、JS的异步任务">1、JS的异步任务<a class="anchor" href="#1、JS的异步任务">·</a></h3><ul><li>JS各种事件</li><li>setTimeout、setInterval 定时器</li><li>Ajax网络请求</li><li>Promise</li><li>async function</li></ul><h3 id="2、几种异步解决方案">2、几种异步解决方案<a class="anchor" href="#2、几种异步解决方案">·</a></h3><ul><li>回调函数</li><li>事件监听(发布/订阅)</li><li>Promise</li><li>Generator</li><li>Async/Await</li></ul><h3 id="3-1、方式1：回调函数">3.1、方式1：回调函数<a class="anchor" href="#3-1、方式1：回调函数">·</a></h3><p>异步编程最基本的方法，举例</p><ul><li><p>假定有两个函数f1和f2，后者等待前者的执行结果</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">f1</span>();  <span class="comment">// 耗时较长的任务，直接这样写会导致阻塞</span></span><br><span class="line"><span class="title function_">f2</span>();</span><br></pre></td></tr></table></figure></li><li><p>改写：</p><p><strong>把同步操作f1变成了异步操作，f1不会堵塞程序运行，相当于先执行程序的主要逻辑，将耗时的操作推迟执行</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params">callback</span>)&#123;<span class="comment">//此时f1就是一个异步任务</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// f1的任务代码</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="title function_">callback</span>(); <span class="comment">// f2的逻辑，会在f1执行完毕后就能执行</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f1</span>(f2);</span><br></pre></td></tr></table></figure></li><li><p>优点：简单易理解</p></li><li><p>缺点：</p><ul><li>不利于代码的阅读和维护，各个部分之间高度耦合</li><li>流程会很混乱，而且每个任务只能指定一个回调函数</li><li><strong>异步回调中，回调函数的执行栈与原函数分离，外部无法抓住异常，异常会变得不可控。这会导致什么呢？？？</strong></li></ul></li></ul><h3 id="3-2、方式2：事件监听">3.2、方式2：事件监听<a class="anchor" href="#3-2、方式2：事件监听">·</a></h3><p>采用事件驱动模式。任务的执行<strong>不取决于代码的顺序，而取决于某个事件是否发生</strong></p><ul><li><p>首先，为f1绑定一个done事件，f2作为回调</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">f1.<span class="title function_">on</span>(<span class="string">&#x27;done&#x27;</span>, f2);  <span class="comment">// f1事件执行完毕后，执行f2</span></span><br></pre></td></tr></table></figure></li><li><p>然后，对f1进行改写：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>)&#123;</span><br><span class="line">　　　　<span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// f1的任务代码</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// f1.trigger(&#x27;done&#x27;)手动触发done事件，从而开始执行f2</span></span><br><span class="line">　　　　　　f1.<span class="title function_">trigger</span>(<span class="string">&#x27;done&#x27;</span>);</span><br><span class="line">　　　　&#125;, <span class="number">1000</span>);</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure></li><li><p>优点：</p><ul><li>易理解，可以绑定多个事件，每个事件可以指定多个回调函数</li><li>可以去耦合</li><li>有利于模块化</li></ul></li><li><p>缺点：整个程序都要变成事件驱动型，运行流程会变得很不清晰</p></li></ul><h3 id="3-3、方式3：发布订阅">3.3、方式3：发布订阅<a class="anchor" href="#3-3、方式3：发布订阅">·</a></h3><p><strong>发布/订阅模式：</strong></p><ul><li>存在一个“信号中心”，某个任务执行完成，就向信号中心发布一个信号；</li><li>其他任务可以向信号订阅这个信号，从而知道什么时候自己可以开始执行；</li></ul><h4 id="1、用class实现">1、用class实现<a class="anchor" href="#1、用class实现">·</a></h4><ol><li><p>创建了一个<code>Emitter</code>类，有两个原型方法<code>on</code>和<code>trigger</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Emitter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// _listener数组，key为自定义事件名，value为执行回调数组-因为可能有多个</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_listener</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">on</span>(<span class="params">type, fn</span>) &#123; <span class="comment">// 订阅 监听事件</span></span><br><span class="line">    <span class="comment">// 判断_listener数组中是否存在该事件命</span></span><br><span class="line">    <span class="comment">// 存在将回调push到事件名对应的value数组中，不存在直接新增</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_listener</span>[type] </span><br><span class="line">      ? <span class="variable language_">this</span>.<span class="property">_listener</span>[type].<span class="title function_">push</span>(fn) </span><br><span class="line">    	: (<span class="variable language_">this</span>.<span class="property">_listener</span>[type] = [fn])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">trigger</span>(<span class="params">type, ...rest</span>) &#123; <span class="comment">// 发布 触发事件</span></span><br><span class="line">    <span class="comment">// 判断该触发事件是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_listener</span>[type]) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 遍历执行该事件回调数组并传递参数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_listener</span>[type].<span class="title function_">forEach</span>(<span class="function"><span class="params">callback</span> =&gt;</span> <span class="title function_">callback</span>(...rest))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="2、使用">2、使用<a class="anchor" href="#2、使用">·</a></h4><p>创建一个emitter实例，接着注册事件，再触发事件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> emitter = <span class="keyword">new</span> <span class="title class_">Emitter</span>()</span><br><span class="line"></span><br><span class="line">emitter.<span class="title function_">on</span>(<span class="string">&quot;done&quot;</span>, <span class="keyword">function</span>(<span class="params">arg1, arg2</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg1, arg2)</span><br><span class="line">&#125;)</span><br><span class="line">emitter.<span class="title function_">on</span>(<span class="string">&quot;done&quot;</span>, <span class="keyword">function</span>(<span class="params">arg1, arg2</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arg2, arg1)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是主程序&#x27;</span>)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    emitter.<span class="title function_">trigger</span>(<span class="string">&quot;done&quot;</span>, <span class="string">&quot;异步参数一&quot;</span>, <span class="string">&quot;异步参数二&quot;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn1</span>();</span><br></pre></td></tr></table></figure><ul><li>这种方法的性质与&quot;事件监听&quot;类似，但是明显优于后者。因为我们可以通过查看&quot;消息中心&quot;，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行</li></ul><h3 id="3-4、方式4：promise">3.4、方式4：promise<a class="anchor" href="#3-4、方式4：promise">·</a></h3><ul><li><p>思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数</p></li><li><p>比如，f1的回调函数f2,可以写成：</p><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title function_">f1</span>().<span class="title function_">then</span>(f2);</span><br></pre></td></tr></table></figure><p>f1改写为promise：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">f1</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pomise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  　　	<span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">       <span class="comment">// f1的任务代码</span></span><br><span class="line">           ....</span><br><span class="line">  　　　　　　<span class="title function_">resolve</span>();</span><br><span class="line">  　　　　&#125;, <span class="number">500</span>);</span><br><span class="line">  　　&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>优点：</p><ol><li><p>可以指定多个回调、错误的回调</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">f1</span>().<span class="title function_">then</span>(f2).<span class="title function_">then</span>(f3);</span><br><span class="line"><span class="title function_">f1</span>().<span class="title function_">then</span>(f2).<span class="title function_">catch</span>(f3);</span><br></pre></td></tr></table></figure></li><li><p>其他三个没有的：</p><p>如果一个任务已经完成，<strong>再添加回调函数（指定then），该回调函数会立即执行</strong>。所以，你不用担心是否错过了某个事件或信号</p></li></ol></li></ul><h3 id="3-5、Generator">3.5、Generator<a class="anchor" href="#3-5、Generator">·</a></h3><h3 id="3-6、async-await">3.6、async await<a class="anchor" href="#3-6、async-await">·</a></h3><h2 id="2-1、Promise概念及关键问题">2.1、Promise概念及关键问题<a class="anchor" href="#2-1、Promise概念及关键问题">·</a></h2><p>一句话：用同步的方式写异步的代码，可用来解决回调地狱问题</p><h3 id="1、是什么">1、是什么<a class="anchor" href="#1、是什么">·</a></h3><ul><li><h5 id="抽象表达">抽象表达:<a class="anchor" href="#抽象表达">·</a></h5><ol><li>Promise <strong>就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。承诺不一定会完成，但是一定都会有一个结果</strong></li><li>Promise 是 JS <code>异步编程</code>的新方案，是一门新技术(ES6 规范) , 备注：旧方案是回调</li></ol></li><li><h5 id="具体表达">具体表达:<a class="anchor" href="#具体表达">·</a></h5><ol><li>从语法上: Promise 是一个<code>构造函数</code>，实例是一个对象，从它可以获取异步操作的消息</li><li>从功能上: promise 对象用来封装一个异步操作，而且Promise 提供统一的 API，可以获取其成功/ 失败的结果值</li></ol></li></ul><h3 id="2、2个特点">2、2个特点:<a class="anchor" href="#2、2个特点">·</a></h3><ol><li>Promise对象的状态不受外界影响。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态</li><li>一旦状态改变，就不会再变，任何时候都可以得到这个结果<ul><li><code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。</li><li>只要这两种情况发生，状态就凝固了。</li><li>如果改变已经发生了，再对<code>Promise</code>对象添加回调函数，会立即得到这个结果。这与事件完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</li></ul></li></ol><h3 id="3、优-缺点：">3、优/缺点：<a class="anchor" href="#3、优-缺点：">·</a></h3><h4 id="3-1、优点：">3.1、优点：<a class="anchor" href="#3-1、优点：">·</a></h4><ul><li><h5 id="以往异步编程模式">以往异步编程模式<a class="anchor" href="#以往异步编程模式">·</a></h5><ul><li>普通异步回调：异步函数的返回值只在短时间内存在，需要提前准备好回调函数来接收它</li><li>嵌套异步回调：异步返回值依赖与另一个返回值，多个会造成回调地狱，代码维护很难</li></ul></li><li><h5 id="promise">promise<a class="anchor" href="#promise">·</a></h5><ol><li><p><strong>指定回调函数的方式更加灵活:</strong></p><ul><li><p>启动异步任务 =&gt; 返回promie对象 =&gt; 给promise对象绑定回调函数(甚至可以在异步任务结束后指定/多个)</p></li><li><p>而旧版必须在启动异步任务前指定</p></li><li><p><code>Promise</code>对象提供统一的接口，使得<strong>控制异步操作更加容易</strong></p></li></ul></li><li><p><strong>支持链式调用, 解决回调地狱问题</strong></p></li></ol></li><li><p>同步的方式写异步的代码，避免了层层嵌套的回调函数</p></li><li><p>promise <code>链式调用</code>：用来解决回调地狱问题，但<code>只是简单改变格式</code>，并没有彻底解决</p></li></ul><h4 id="3-2、缺点：">3.2、缺点：<a class="anchor" href="#3-2、缺点：">·</a></h4><ol><li><strong>一旦新建它就会立即执行，无法中途取消</strong></li><li>如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部</li><li>当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）</li><li>一眼看上去都是promise的API，而且链式语法总觉得不好看，不优雅</li></ol><h3 id="4、onRejected和catch区别">4、onRejected和catch区别<a class="anchor" href="#4、onRejected和catch区别">·</a></h3><p><code>promise.then(onresolved, onRejected)</code>在 <code>onresolved</code>回调中发生异常时：</p><ul><li><p><code>onRejected</code>中是捕获不到这个异常，可以在末尾多加一个<code>then</code>从而达到和<code>catch</code>相同的作用（流转到下一个错误处理）</p></li><li><p><strong>使用<code>catch</code>可以捕获到前面的<code>onRejected</code>的异常</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是对的&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;111&#x27;</span>  <span class="comment">// 抛出异常</span></span><br><span class="line">  &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"><span class="comment">//情况1： 我是对的  111   返回undefined的resolved的promise</span></span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res), <span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err))</span><br><span class="line"><span class="comment">// 情况2：    </span></span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 我是对的  err:111   返回undefined的resolved的promise</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err:&quot;</span> + err) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="5、then中抛错未处理">5、then中抛错未处理<a class="anchor" href="#5、then中抛错未处理">·</a></h3><ul><li><p>如果在then中抛错，而没有对错误进行处理(catch)，那么会一直保持reject状态的promise，就不会往下执行了</p></li><li><p>直到catch了错误，状态变为resolved</p></li><li><p>promise的缺点之一就是无法让promise中断，利用这个特性可让Promise中断执行</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">	.<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  	<span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 错误：未声明的变量</span></span><br><span class="line">  	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Task 1&quot;</span>);</span><br><span class="line">	&#125;)<span class="comment">//跳过了第二个then</span></span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Task 2&quot;</span>);</span><br><span class="line">	&#125;)<span class="comment">//如果我们没有处理这个错误(无catch)的话，就不会往下执行了</span></span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 这时候变成undefined的resolved的promise</span></span><br><span class="line">  	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err:&quot;</span> + err)</span><br><span class="line">	&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;finaltask&quot;</span>, res)</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// err:ReferenceError: a is not defined</span></span><br><span class="line"><span class="comment">// finaltask  undefined</span></span><br></pre></td></tr></table></figure></li><li><h4 id="流程图：">流程图：<a class="anchor" href="#流程图：">·</a></h4></li></ul><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/14/17041c4ba347afe2~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%"><h3 id="6、异步回调中抛错catch捕捉不到">6、异步回调中抛错catch捕捉不到<a class="anchor" href="#6、异步回调中抛错catch捕捉不到">·</a></h3><ol><li><p>在Promise对象的处理器函数中直接抛出错误，<code>catch</code>是可以捕捉到的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;这是一个错误&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line">p.<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>)=&gt;</span>&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(error) &#125;);</span><br></pre></td></tr></table></figure></li><li><p>在Promise对象的处理器函数中异步抛错，**catch捕获不到：**为什么</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;这是一个错误&#x27;</span>) &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;);</span><br><span class="line">p.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span>=&gt;</span>&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(error) &#125;);</span><br></pre></td></tr></table></figure><p>JS 事件循环列表有宏任务与微任务之分，setTimeOut是宏任务， promise是微任务，执行顺序不同</p><ul><li>执行栈进入promise 触发setTimeOut，setTimeOut回调函数入宏任务队列</li><li>执行promise的catch方法，入微任务队列，此时setTimeOut回调还没执行</li><li>执行栈检查发现当前微任务队列执行完毕，开始执行宏任务队列</li><li>执行<code>throw new Error('这是一个错误')</code> 此<strong>时这个异常其实是在promise外部抛出的</strong></li></ul></li></ol><ul><li><p><strong>解决</strong>：使用<code>try catch</code>捕获异常主动触发<code>reject</code> 不太理解？？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123; </span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;这是一个错误&#x27;</span>) </span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">       <span class="title function_">reject</span>(e)</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;);</span><br><span class="line">p.<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>)=&gt;</span>&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(error) &#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="7、中断-promise-链">7、中断 promise 链?<a class="anchor" href="#7、中断-promise-链">·</a></h3><p>场景：有5个then()，但其中有条件判断,如当我符合或者不符合第三个then条件时,要直接中断链式调用,不再走下面的then,该如何？</p><ul><li><p>回调函数中返回一个 <code>pendding</code> 状态的<code>promise 对象</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  	<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);&#125;, <span class="number">1000</span>);&#125;</span><br><span class="line">);</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;);&#125;)<span class="comment">//有且只有这一个方式</span></span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>);&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">333</span>);&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">warn</span>(reason);&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="8、一个-promise-指定多个成功-失败回调函数-都会调用吗">8、一个 promise 指定多个成功/失败回调函数, 都会调用吗?<a class="anchor" href="#8、一个-promise-指定多个成功-失败回调函数-都会调用吗">·</a></h3><ul><li>当 promise <code>改变为对应状态时</code>都会调用,改变状态后,多个回调函数都会调用,并不会自动停止</li></ul><blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;  <span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);&#125;);</span><br><span class="line">&gt;<span class="comment">///指定回调1</span></span><br><span class="line">&gt;p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); &#125;);</span><br><span class="line">&gt;<span class="comment">//指定回调2</span></span><br><span class="line">&gt;p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="title function_">alert</span>(value);&#125;);</span><br></pre></td></tr></table></figure></blockquote><h3 id="9、改变-promise-状态和指定回调函数谁先谁后">9、改变 promise 状态和指定回调函数谁先谁后?<a class="anchor" href="#9、改变-promise-状态和指定回调函数谁先谁后">·</a></h3><p>都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调</p><h4 id="1、先指定回调再改变状态">1、先指定回调再改变状态<a class="anchor" href="#1、先指定回调再改变状态">·</a></h4><ul><li><p>先指定回调–&gt; 再改变状态 --&gt;改变状态后才进入异步队列执行回调函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">//异步写法,这样写会先指定回调,再改变状态</span></span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;<span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>); &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(value);&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure></li><li><p>当状态发生改变时, 回调函数就会调用, 得到数据</p></li></ul><h4 id="2、先改状态再指定回调">2、先改状态再<code>指定</code>回调<a class="anchor" href="#2、先改状态再指定回调">·</a></h4><ul><li><p>先改状态再<code>指定</code>回调：</p><p>方法1：在执行器中直接调用 resolve()/reject()</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">//这是同步写法,这样写会先改变状态,再指定回调</span></span><br><span class="line">	<span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>); </span><br><span class="line">&#125;);</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(value);&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><p>方法2：延迟更长时间才调用 then() ，在<code>.then()</code>外再包一层例如延时器</p></li><li><p>当指定回调时, 回调函数就会调用, 得到数据</p></li></ul><h4 id="3、个人理解–结合源码">3、个人理解–结合源码<a class="anchor" href="#3、个人理解–结合源码">·</a></h4><p>源码中,promise的状态是通过一个<code>默认为padding</code>的变量进行判断：</p><ol><li><p>当你<code>resolve/reject</code>延时(异步导致当then加载时,状态还未修改)后,这时直接进行p.then()会发现,目前状态还是<code>进行中</code>，如果只是这样会导致只有同步操作才能成功</p></li><li><p>所以promise将传入的<code>回调函数</code>拷贝到promise对象实例上,然后在<code>resolve/reject</code>的执行过程中再进行调用,达到异步的目的</p></li></ol><h2 id="2-2、Promise用法">2.2、Promise用法<a class="anchor" href="#2-2、Promise用法">·</a></h2><h3 id="1-Promise-构造函数-Promise-excutor">1- Promise 构造函数: Promise (excutor) {}<a class="anchor" href="#1-Promise-构造函数-Promise-excutor">·</a></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">resolve</span>(p1);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>executor 函数: 执行器 (resolve, reject) =&gt; {}，会在 <strong>Promise 内部立即<code>同步调用</code></strong></li><li>resolve 函数：会将promise状态改成resolved，<strong>参数正常的值/另一个 Promise 实例</strong></li><li>reject 函数：<strong>参数通常是<code>Error</code>对象的实例，表示抛出的错误</strong></li></ul><h4 id="1、参数传递问题：">1、参数传递问题：<a class="anchor" href="#1、参数传递问题：">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">resolve</span>(p1);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>p1：正常值，参数p1会作为promise的结果，保存在promise对象的<strong>promiseResult</strong>属性中，被传递给<strong>回调函数的参数</strong></li><li>p1：promise对象，<strong><code>p1</code>的状态决定了<code>p2</code>的状态</strong><ul><li>如果<code>p1</code>状态是<code>pending</code>，那<code>p2</code>的回调函数会等待<code>p1</code>的状态改变</li><li>如果<code>p1</code>状态已经是<code>resolved</code>或者<code>rejected</code>，那么<code>p2</code>的回调函数将会立刻执行</li></ul></li></ul><h4 id="2、resolve或reject对执行器函数的执行影响">2、<code>resolve</code>或<code>reject</code>对执行器函数的执行影响<a class="anchor" href="#2、resolve或reject对执行器函数的执行影响">·</a></h4><ul><li><p>注意，调用<code>resolve</code>或<code>reject</code>并不会终结 Promise 的参数函数的执行，后面的仍然是同步任务</p></li><li><p>而then：是在微任务中执行的</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(r);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><ul><li>调用<code>resolve(1)</code>以后，后面的<code>console.log(2)</code>还是会执行，并且会首先打印出来。这是因为<strong>立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务</strong></li></ul></li></ul><h4 id="3、return的影响：">3、return的影响：<a class="anchor" href="#3、return的影响：">·</a></h4><p>一般来说，一个promise对象内部<code>resolve</code>或<code>reject</code>以后，Promise 的使命就完成了。但执行器本身后面还是执行的，所以，最好在它们前面加上<code>return</code>语句，这样就不会有意外</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 后面的语句不会执行</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-原型方法then">2-原型方法then<a class="anchor" href="#2-原型方法then">·</a></h3><p>Promise实例生成以后，可用<code>then</code>方法指定<code>resolved</code>状态和<code>reject</code>状态的回调函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">then</span>(onFulfilled [, onRejected])</span><br></pre></td></tr></table></figure><h4 id="1、返回值：返回一个新的-promise-对象">1、返回值：返回一个新的 promise 对象<a class="anchor" href="#1、返回值：返回一个新的-promise-对象">·</a></h4><ul><li>返回一个新的 promise 对象，因此可用链式写法，即<code>then</code>后面再<code>then</code></li><li>链式写法中，后一个回调函数，会等待前<code>Promise</code>对象的状态发生变化，才会被调用</li></ul><h4 id="2、返回结果promise-对象的状态-重要5条">2、返回结果promise 对象的状态 重要5条<a class="anchor" href="#2、返回结果promise-对象的状态-重要5条">·</a></h4><p>总结：由 then()指定<strong>的回调函数执行的结果决定</strong></p><ol><li><p>如果没有return值，那会返回的新promise变为resolved，传参undefined</p></li><li><p>如果return非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值</p></li><li><p>如果<strong>then里抛出异常</strong>，<code>then</code>方法的第二个参数onRejected是监测不到当前<code>then</code>方法回调异常的，promise规范规定调用失败态方法(reject)<strong>流转到下一个<code>then</code>的onRejected</strong></p></li><li><p>如果return另一个新 promise, 此 promise 的结果就会成为新 promise 的结果</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="title function_">resolve</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> result = p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 1. 如果只是执行语句，没有返回，新promise变为resolved，且传参undefined</span></span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line"><span class="comment">// 2. 返回结果是非 Promise 类型的对象,新 promise 变为 resolved</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">521</span>;</span><br><span class="line"><span class="comment">// 3. 抛出错误 ,变为 rejected，流转到下一个then的onRejected</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="string">&#x27;出了问题&#x27;</span>;</span><br><span class="line"><span class="comment">// 4. 返回结果是 Promise 对象,此 promise 的结果就会成为新 promise 的结果</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 流转到下一个then的onRejected</span></span><br><span class="line">  	<span class="comment">// resolve(&#x27;success&#x27;);</span></span><br><span class="line">  		 <span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">  		&#125;);</span><br><span class="line">  	&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  		 <span class="variable language_">console</span>.<span class="title function_">warn</span>(reason);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>如果<code>then</code>方法没有传入任何回调，则继续向下传递(即所谓的值穿透)</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> <span class="number">2</span>)</span><br><span class="line">.<span class="title function_">then</span>()</span><br><span class="line">.<span class="title function_">then</span>()</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data) <span class="comment">// 2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-原型方法catch">3-原型方法catch<a class="anchor" href="#3-原型方法catch">·</a></h3><p>then()的语法糖, 相当于: then(undefined, onRejected)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">p.<span class="title function_">catch</span>(onRejected);</span><br><span class="line">p.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="1、返回值：返回一个新的promise实例，因此后面还可以接着调用then-方法">1、返回值：返回一个新的promise实例，因此后面还可以接着调用<code>then()</code>方法<a class="anchor" href="#1、返回值：返回一个新的promise实例，因此后面还可以接着调用then-方法">·</a></h4><ol><li><p>如果 <code>onRejected</code>回调抛出一个错误或返回一个本身失败的 Promise ，返回rejected的promise</p></li><li><p>否则返回成功的promise</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fn1</span>()</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">  <span class="comment">// 这里只是return了错误信息，并没有抛出错误或者返回一个失败promise</span></span><br><span class="line">  <span class="comment">// 所以第一个`catch`执行返回的promise对象是resolved</span></span><br><span class="line">    <span class="keyword">return</span> err  </span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">  &#125;)</span><br><span class="line">	.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></li></ol><h4 id="2、catch可以捕获什么？">2、catch可以捕获什么？<a class="anchor" href="#2、catch可以捕获什么？">·</a></h4><ol><li><h5 id="Promise-内部的错误">Promise 内部的错误<a class="anchor" href="#Promise-内部的错误">·</a></h5><p>如果没有用<code>catch()</code>方法指定错误处理的回调函数，<strong>Promise 对象抛出的错误不会传递到外层代码</strong>，即不会有任何反应</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> someAsyncThing = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    <span class="title function_">resolve</span>(x + <span class="number">2</span>);<span class="comment">//内部有语法错误。浏览器运行到这一行，会抛错，但不会退出进程、终止脚本执行</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m = <span class="title function_">someAsyncThing</span>();  <span class="comment">//m是rejected的，promise中的不会执行下去</span></span><br><span class="line">m.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="comment">//不执行</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;everything is great&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="title function_">alert</span>(<span class="number">11</span>,err))<span class="comment">//不执行</span></span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="title function_">alert</span>(<span class="number">22</span>, err)) <span class="comment">//不执行</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span>) &#125;, <span class="number">2000</span>); <span class="comment">// 仍然执行</span></span><br><span class="line"><span class="comment">// Uncaught (in promise) ReferenceError: x is not defined</span></span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>但如果将then替换为catch：m.then —m.catch，promise就能继续执行下去</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">everything is great</span><br><span class="line"><span class="number">11</span> <span class="number">22</span></span><br></pre></td></tr></table></figure></li><li><h5 id="then-方法中抛出错误"><code>then()</code>方法中抛出错误<a class="anchor" href="#then-方法中抛出错误">·</a></h5><p>在<code>then()</code>方法里面定义 Reject 状态的回调函数，捕获不到then里面的错误</p><p>但会被<strong>后面的<code>catch()</code>方法捕获。</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fn1</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">  &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></li><li><h5 id="promise异常穿透">promise异常穿透<a class="anchor" href="#promise异常穿透">·</a></h5><p>前面任何操作出了异常, 都会传到最后失败的回调中处理；所以</p><ul><li>可以在每个then()的第二个回调函数中进行err处理</li><li>也可以利用异常穿透特性，到最后用<code>catch</code>去承接统一处理</li><li>两者一起用时,前者会生效(因为err已经将其处理,就不会再往下穿透)而走不到后面的catch</li></ul></li><li><p>【注意】：catch无法捕获在它后面出现的错误，案例1：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;oh no&#x27;</span>, error);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;carry on&#x27;</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&#x27;error&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// carry on</span></span><br></pre></td></tr></table></figure><ul><li>案例2：resolve之后，在下一轮事件循环中抛错。那时候，**Promise 的运行已经结束了，**所以这个错误是在 Promise 函数体外抛出的，<strong>会冒泡到最外层，成了未捕获的错误</strong></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;test&#x27;</span>) &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;);</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(value) &#125;);</span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="comment">// Uncaught Error: test</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="4-原型方法finally">4-原型方法finally<a class="anchor" href="#4-原型方法finally">·</a></h3><ul><li><p>在promise结束时，不管成功还是失败都将执行其<code>onFinally</code>回调</p></li><li><p>不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，与状态无关的，不依赖于 Promise 的执行结果</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">p.<span class="title function_">finally</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 返回状态为(resolved 或 rejected)</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">promise</span><br><span class="line">.<span class="title function_">then</span>(</span><br><span class="line">  <span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;,<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> error;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-静态方法Promise-resolve">1-静态方法Promise.resolve :<a class="anchor" href="#1-静态方法Promise-resolve">·</a></h3><ul><li>接收一个值，将现有对象转为Promise 对象</li></ul><blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">&gt;<span class="comment">// 等价于</span></span><br><span class="line">&gt;<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&#x27;foo&#x27;</span>))</span><br></pre></td></tr></table></figure></blockquote><h4 id="1、传参情况4种">1、传参情况4种<a class="anchor" href="#1、传参情况4种">·</a></h4><ol><li><p><strong>参数是一个 Promise 实例</strong>：<code>Promise.resolve</code>将原封不动地返回这个实例</p></li><li><p><strong>参数是一个原始值，或一个不具有<code>then()</code>方法的对象</strong>：返回一个新的<code>resolved</code>的 Promise 对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Hello</span></span><br></pre></td></tr></table></figure></li><li><p><strong>参数是空</strong>：直接返回一个<code>resolved</code>状态的 Promise 对象</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>();</span><br><span class="line">p.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>参数是一个<code>thenable</code>对象：</strong><code>Promise.resolve()</code>将这个对象转为 Promise 对象，然后立即执行<code>thenable</code>对象的<code>then()</code>方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  <span class="attr">then</span>: <span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">resolve</span>(<span class="number">42</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(thenable);</span><br><span class="line">p1.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);  <span class="comment">// 42</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h4 id="2、执行顺序">2、执行顺序<a class="anchor" href="#2、执行顺序">·</a></h4><p>立即<code>resolve()</code>的 Promise 对象，是在本轮“事件循环”结束时执行，而不是在下一轮“事件循环”开始时</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3.在下一轮“事件循环”开始时执行</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;three&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//2. Promise.resolve()在本轮“事件循环”结束时执行</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;two&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;one&#x27;</span>);  <span class="comment">//1. 立即执行</span></span><br><span class="line"><span class="comment">// one two  three</span></span><br></pre></td></tr></table></figure><h3 id="2-静态方法Promise-reject">2-静态方法Promise.reject :<a class="anchor" href="#2-静态方法Promise-reject">·</a></h3><ul><li><p>返回一个失败的 promise 对象,直接改变promise状态</p></li><li><p><code>Promise.reject()</code>方法的参数，会原封不动地作为<code>reject</code>的理由，变成后续方法的参数</p></li></ul><blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">&gt;<span class="comment">// 等同于</span></span><br><span class="line">&gt;<span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>))</span><br><span class="line"></span><br><span class="line">&gt;<span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">&gt;.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">&gt;<span class="variable language_">console</span>.<span class="title function_">log</span>(e === <span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">&gt;&#125;)<span class="comment">// true</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="3-静态方法Promise-all">3-静态方法Promise.all :<a class="anchor" href="#3-静态方法Promise-all">·</a></h3><ul><li>iterable类型：代表可迭代对象，<code>Array</code>、<code>Map</code>和<code>Set</code>都属于<code>iterable</code>类型</li><li>应用场景：有一个接口，需要其他两个或多个接口返回的数据作为参数时</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Promise.all(iterable)</span><br></pre></td></tr></table></figure><h3 id="4-静态方法Promise-race">4-静态方法Promise.race :<a class="anchor" href="#4-静态方法Promise-race">·</a></h3><ul><li>迭代对象中状态全部改变才会执行</li><li>只要迭代对象中有一个状态改变了，它的状态就跟着改变，并将那个改变状态实例的返回值传递给回调函数</li><li>p1延时,开启了异步,内部正常是同步进行,所以<code>p2&gt;p3&gt;p1</code>,结果是<code>P2</code></li></ul><blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>(iterable)</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  	<span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>);</span><br><span class="line"> &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Success&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;Oh Yeah&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2, p3]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br></pre></td></tr></table></figure></blockquote><h2 id="3、Generaor">3、Generaor<a class="anchor" href="#3、Generaor">·</a></h2><h3 id="1、协程">1、协程<a class="anchor" href="#1、协程">·</a></h3><ul><li><p>协程：多个线程互相协作，完成异步任务。它的运行流程大致如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一步，协程A开始执行。</span><br><span class="line"></span><br><span class="line">第二步，协程A执行到一半，进入暂停，执行权转移到协程B。</span><br><span class="line"></span><br><span class="line">第三步，（一段时间后）协程B交还执行权。</span><br><span class="line"></span><br><span class="line">第四步，协程A恢复执行。</span><br></pre></td></tr></table></figure><p>上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行</p></li></ul><h4 id="举例文件读取：">举例文件读取：<a class="anchor" href="#举例文件读取：">·</a></h4><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">asnycJob</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// ...其他代码</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">yield</span> <span class="title function_">readFile</span>(fileA);</span><br><span class="line"><span class="comment">// ...其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><ul><li>asyncJob 是一个协程，它的奥妙就在其中的 yield 命令。它表示执行到此处，执行权将交给其他协程。也就是说，yield命令是异步两个阶段的分界线</li><li>协程遇到 yield 命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。</li></ul><h3 id="2、Generator-函数">2、Generator 函数<a class="anchor" href="#2、Generator-函数">·</a></h3><p>Generator 函数是<strong>协程在 ES6 的实现</strong>，是一种异步解决方案。最大特点就是可以交出函数的执行权（即暂停执行）</p><ul><li>语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态</li><li>Generator 函数除了状态机，还是一个遍历器对象生成函数<ul><li>可暂停函数, yield可暂停。next方法可启动</li><li>yield表达式本身没有返回值，或者说总是返回undefined</li><li>next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值</li></ul></li></ul><h4 id="运行方式举例">运行方式举例<a class="anchor" href="#运行方式举例">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>))</span><br><span class="line">  <span class="keyword">let</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>)</span><br><span class="line">  <span class="keyword">return</span> (x + y + z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = <span class="title function_">foo</span>(<span class="number">5</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>())   <span class="comment">// =&gt; &#123;value: 6, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>(<span class="number">12</span>)) <span class="comment">// =&gt; &#123;value: 8, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>(<span class="number">13</span>)) <span class="comment">// =&gt; &#123;value: 42, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>代码分析：</p><ul><li><p>首先 Generator 函数调用和普通函数不同，它会返回一个迭代器</p></li><li><p>当执行第一次 next 时，传参会被忽略，并且函数暂停在 yield (x + 1) 处，所以返回 5 + 1 = 6</p></li><li><p>当执行第二次 next 时，传入的参数12就会被当作上一个yield表达式的返回值，如果你不传参，yield 永远返回 undefined。此时 let y = 2 * 12，所以第二个 yield 等于 2 * 12 / 3 = 8</p></li><li><p>当执行第三次 next 时，传入的参数13就会被当作上一个yield表达式的返回值，所以 z = 13, x = 5, y = 24，相加等于 42</p></li></ul><h4 id="文件读取举例">文件读取举例<a class="anchor" href="#文件读取举例">·</a></h4><ul><li>有三个本地文件，分别1.txt,2.txt和3.txt，内容都只有一句话，<strong>下一个请求依赖上一个请求的结果</strong>，想通过Generator函数依次调用三个文件</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">read</span>(<span class="params">file</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(file, <span class="string">&#x27;utf8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="title function_">reject</span>(err)</span><br><span class="line">      <span class="title function_">resolve</span>(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">r</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> r1 = <span class="keyword">yield</span> <span class="title function_">read</span>(<span class="string">&#x27;./1.txt&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> r2 = <span class="keyword">yield</span> <span class="title function_">read</span>(r1)</span><br><span class="line">  <span class="keyword">let</span> r3 = <span class="keyword">yield</span> <span class="title function_">read</span>(r2)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(r1)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(r2)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(r3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = <span class="title function_">r</span>()</span><br><span class="line"><span class="keyword">let</span> &#123; value, done &#125; = it.<span class="title function_">next</span>()</span><br><span class="line">value.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>) &#123; <span class="comment">// value是个promise</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data) <span class="comment">//data=&gt;2.txt</span></span><br><span class="line">  <span class="keyword">let</span> &#123; value, done &#125; = it.<span class="title function_">next</span>(data)</span><br><span class="line">  value.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data) <span class="comment">//data=&gt;3.txt</span></span><br><span class="line">    <span class="keyword">let</span> &#123; value, done &#125; = it.<span class="title function_">next</span>(data)</span><br><span class="line">    value.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data) <span class="comment">//data=&gt;结束</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 2.txt=&gt;3.txt=&gt;结束</span></span><br></pre></td></tr></table></figure><ul><li>手动迭代<code>Generator</code> 函数很麻烦，实现逻辑有点绕，而实际开发一般会配合 <code>co</code> 库去使用</li><li><strong><code>co</code>是一个为Node.js和浏览器打造的基于生成器的流程控制工具，借助于Promise，你可以使用更加优雅的方式编写非阻塞代码</strong></li></ul><h4 id="安装co库后：">安装co库后：<a class="anchor" href="#安装co库后：">·</a></h4><ul><li>npm install co，代码更简单</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">r</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> r1 = <span class="keyword">yield</span> <span class="title function_">read</span>(<span class="string">&#x27;./1.txt&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> r2 = <span class="keyword">yield</span> <span class="title function_">read</span>(r1)</span><br><span class="line">  <span class="keyword">let</span> r3 = <span class="keyword">yield</span> <span class="title function_">read</span>(r2)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(r1)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(r2)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(r3)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> co = <span class="built_in">require</span>(<span class="string">&#x27;co&#x27;</span>)</span><br><span class="line"><span class="title function_">co</span>(<span class="title function_">r</span>()).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 2.txt=&gt;3.txt=&gt;结束=&gt;undefined</span></span><br></pre></td></tr></table></figure><h4 id="回调地狱问题">回调地狱问题<a class="anchor" href="#回调地狱问题">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="title function_">fetch</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">ajax</span>(url, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">ajax</span>(url1, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">ajax</span>(url2, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = <span class="title function_">fetch</span>()</span><br><span class="line"><span class="keyword">let</span> result1 = it.<span class="title function_">next</span>()</span><br><span class="line"><span class="keyword">let</span> result2 = it.<span class="title function_">next</span>()</span><br><span class="line"><span class="keyword">let</span> result3 = it.<span class="title function_">next</span>()</span><br></pre></td></tr></table></figure><h3 id="3、优缺点">3、优缺点<a class="anchor" href="#3、优缺点">·</a></h3><h4 id="优点">优点<a class="anchor" href="#优点">·</a></h4><ul><li>优雅的流程控制方式，可以让函数可中断执行，在某些特殊需求里还是很实用的</li></ul><h4 id="缺点">缺点<a class="anchor" href="#缺点">·</a></h4><ul><li>Generator 函数的执行必须靠执行器，所以才有了 co 函数库，但co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，只针对<strong>异步处理来说，还是不太方便</strong></li></ul><h2 id="4、async、await">4、async、await<a class="anchor" href="#4、async、await">·</a></h2><p>JS异步操作的最终且最优雅的解决方案</p><h3 id="0、async-await带来了什么">0、async/await带来了什么<a class="anchor" href="#0、async-await带来了什么">·</a></h3><p>使用async/await，你可以轻松地达成之前使用生成器和co函数所做到的工作,它有如下特点：</p><h4 id="1、优点">1、优点<a class="anchor" href="#1、优点">·</a></h4><ol><li><p>内置执行器</p><p>Generator 函数的执行必须靠执行器，所以才有了 co 函数库；</p><p>而 <code>async</code> 函数自带执行器，也就是说，<code>async</code> 函数的执行，与普通函数一模一样，只要一行</p></li><li><p>更好的语义、结构清晰</p><p><code>async</code> 和 <code>await</code>，比起 <code>*</code> 和 <code>yield</code>，语义更清楚了，几乎跟同步写法一样，十分优雅</p><p><code>async</code> 表示函数里有异步操作，<code>await</code> 表示紧跟在后面的表达式需要等待结果</p></li><li><p>更广的适用性</p><p>co 函数库约定，<code>yield</code> 命令后面只能是 Thunk 函数或 Promise 对象</p><p>而 <code>async</code> 函数的 <code>await</code> 命令后面，可以跟 Promise 对象和原始类型的值(数值、字符串和布尔值，但这时等同于同步操作)</p></li><li><p>更好的错误处理</p><p>链式调用了很多promises，一级接一级。紧接着，promises链中某处出错。此链条的错误堆栈信息并没用线索指示错误到底出现在哪里</p></li></ol><h4 id="2、缺点">2、缺点<a class="anchor" href="#2、缺点">·</a></h4><ul><li><p>滥用 <code>await</code> 可能会导致性能问题</p><p>因为 <code>await</code> 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性</p></li></ul><h3 id="1、async返回值">1、async返回值<a class="anchor" href="#1、async返回值">·</a></h3><p>一个函数如果加上 <strong>async</strong> ，那么该函数就会<strong>返回一个 Promise</strong>：return的情况分析</p><ul><li><h5 id="返回值为promise，状态和值取决于这个promise">返回值为promise，状态和值取决于这个promise<a class="anchor" href="#返回值为promise，状态和值取决于这个promise">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        <span class="comment">// resolve(99);</span></span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        <span class="title function_">reject</span>(<span class="number">66</span>); </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 新的promise状态成功,值为99</span></span><br><span class="line"><span class="comment">// 2 新的promise状态失败,值为66</span></span><br></pre></td></tr></table></figure></li><li><h5 id="函数返回非promise，则会被包装为一个立即resolve的Promise对象，值为返回的非promise值">函数返回非promise，则会被包装为一个立即resolve的Promise对象，值为返回的非promise值<a class="anchor" href="#函数返回非promise，则会被包装为一个立即resolve的Promise对象，值为返回的非promise值">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>()) <span class="comment">// 成功promsie,值为1</span></span><br></pre></td></tr></table></figure></li><li><h5 id="函数返回值为undefined-状态成功-值为undefined">函数返回值为undefined.状态成功,值为undefined<a class="anchor" href="#函数返回值为undefined-状态成功-值为undefined">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>());<span class="comment">//  成功promise,值为undefined</span></span><br></pre></td></tr></table></figure></li><li><h5 id="函数体内抛出异常">函数体内抛出异常<a class="anchor" href="#函数体内抛出异常">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&quot;异常&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fn</span>()); <span class="comment">// 失败promise,值为&quot;异常&quot;;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2、await">2、await<a class="anchor" href="#2、await">·</a></h3><h4 id="1、await在等什么？">1、await在等什么？<a class="anchor" href="#1、await在等什么？">·</a></h4><p><code>await</code> <strong>在等待一个异步完成</strong>，等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值</p><ul><li><p><code>await</code> 后面不是Promise对象，直接返回对应的值，效果等同于直接return</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="number">123</span>;   <span class="comment">// 等同于  return 123;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>await</code> 后面是Promise对象，会造成异步函数暂停执行先返回，并且等待 promise 的解决，<strong>等到异步操作完成，再接着执行函数体内后面的语句</strong>。所以<strong>会阻塞后面的代码</strong></p></li><li><p><code>await</code>一个<code>thenable</code>对象（即定义了<code>then</code>方法的对象），<code>await</code>会将其等同于 Promise 对象</p></li></ul><h4 id="2、为什么await-只能在-async-函数中使用">2、为什么<code>await</code> 只能在 <code>async</code> 函数中使用<a class="anchor" href="#2、为什么await-只能在-async-函数中使用">·</a></h4><ul><li><code>await</code> 会阻塞后面代码，如果允许我们直接使用 <code>await</code> 的话，假如我们使用<code>await</code>等待一个消耗时间比较长的异步请求，那代码直接就阻塞不往下执行了，只能等待 <code>await</code> 拿到结果才会执行下面的代码，那不乱套了</li><li>而 <code>async</code> 函数调用不会造成阻塞，因为它内部所有的阻塞都被封装在一个 Promise 对象中异步执行，所以才规定 <code>await</code> 必须在 <code>async</code> 函数中</li></ul><h4 id="3、await后面代码是微任务microtask">3、await后面代码是微任务microtask<a class="anchor" href="#3、await后面代码是微任务microtask">·</a></h4><p>实际上<strong>await是一个让出线程的标志</strong>，因为async await 本身就是promise+generator的语法糖。所以await后面的代码是微任务microtask</p><ul><li>await后面的表达式会先执行一遍</li><li>将await后面的代码加入到微任务microtask中</li><li>然后就会跳出整个async函数来执行后面的代码</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 start&#x27;</span>); <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">async2</span>();</span><br><span class="line">  <span class="comment">// 3.1 不会执行，添加到微任务</span></span><br><span class="line">  <span class="comment">// 5 真正执行是在微任务中执行</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 end&#x27;</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async2&#x27;</span>); <span class="comment">//3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>);<span class="comment">//4</span></span><br></pre></td></tr></table></figure><h4 id="4、读取文件的例子重写">4、读取文件的例子重写<a class="anchor" href="#4、读取文件的例子重写">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">read</span>(<span class="params">file</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    fs.<span class="title function_">readFile</span>(file, <span class="string">&#x27;utf8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="title function_">reject</span>(err)</span><br><span class="line">      <span class="title function_">resolve</span>(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">readResult</span>(<span class="params">params</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> p1 = <span class="keyword">await</span> <span class="title function_">read</span>(params, <span class="string">&#x27;utf8&#x27;</span>)<span class="comment">//await后面跟的是一个Promise实例</span></span><br><span class="line">    <span class="keyword">let</span> p2 = <span class="keyword">await</span> <span class="title function_">read</span>(p1, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> p3 = <span class="keyword">await</span> <span class="title function_">read</span>(p2, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p1&#x27;</span>, p1)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p2&#x27;</span>, p2)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p3&#x27;</span>, p3)</span><br><span class="line">    <span class="keyword">return</span> p3</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">readResult</span>(<span class="string">&#x27;1.txt&#x27;</span>).<span class="title function_">then</span>( <span class="comment">// async函数返回的也是个promise</span></span><br><span class="line">  <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">)</span><br><span class="line"><span class="comment">// p1 2.txt</span></span><br><span class="line"><span class="comment">// p2 3.txt</span></span><br><span class="line"><span class="comment">// p3 结束</span></span><br><span class="line"><span class="comment">// 结束</span></span><br></pre></td></tr></table></figure><h3 id="3、处理异常">3、处理异常<a class="anchor" href="#3、处理异常">·</a></h3><h4 id="错误导致中断">错误导致中断<a class="anchor" href="#错误导致中断">·</a></h4><p>任何一个<code>await</code>后面的 <strong>Promise 对象变为<code>reject</code>状态</strong>，那么<strong>整个<code>async</code>函数都会中断执行</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;hello world&#x27;</span>); <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="catch">catch<a class="anchor" href="#catch">·</a></h4><p><code>await</code>命令后面的 Promise 对象如果变为<code>reject</code>状态，则<code>reject</code>的参数会被<code>catch</code>的回调接收</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;出错了&#x27;</span>);  <span class="comment">//这里如果在await前面加上return，效果是一样的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>()</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(v))</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error&#x27;</span>,e))</span><br><span class="line"><span class="comment">// error 出错了</span></span><br></pre></td></tr></table></figure><h4 id="try…catch">try…catch<a class="anchor" href="#try…catch">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> <span class="title function_">ajax</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结：">总结：<a class="anchor" href="#总结：">·</a></h4><p>假如希望即使前一个异步操作失败，也不要中断后面的异步操作：</p><ul><li>方法1：第一个<code>await</code>放在<code>try...catch</code>结构里面。这样不管这个异步操作是否成功，第二个<code>await</code>都会执行</li><li>方法2：<code>await</code>后面的 Promise 对象再跟一个<code>catch</code>方法处理前面可能出现的错误</li></ul><h3 id="4、async-await继、并发、promise-all">4、async/await继、并发、promise.all<a class="anchor" href="#4、async-await继、并发、promise-all">·</a></h3><h4 id="1、继发及其应用场景">1、继发及其应用场景<a class="anchor" href="#1、继发及其应用场景">·</a></h4><p>await本身是继发的</p><ul><li>当函数执行的时候，一旦遇到<code>await</code>就会先返回，<strong>等到异步操作完成，再接着执行函数体内后面的语句</strong>，比较耗时</li><li>所以如果<strong>多个异步代码没有依赖性</strong>却使<strong>用了 await 会导致性能上的降低</strong></li><li>因此，<strong>代码没有依赖性的话，完全可以并发的方式</strong></li></ul><p><strong>经常会遇到这种业务，多个请求，每个请求依赖于上一个请求的结果。</strong></p><ul><li>用setTimeout模拟异步操作，用Promise和Async/Await分别来实现下</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">analogAsync</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(n + <span class="number">500</span>), n);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`step1 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">analogAsync</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`step2 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">analogAsync</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn3</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`step3 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">analogAsync</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用Promise">使用Promise:<a class="anchor" href="#使用Promise">·</a></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> time1 = <span class="number">0</span></span><br><span class="line">  <span class="title function_">fn1</span>(time1)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">time2</span>) =&gt;</span> <span class="title function_">fn2</span>(time2))</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">time3</span>) =&gt;</span> <span class="title function_">fn3</span>(time3))</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`result is <span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">  	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure><h5 id="使用async-await">使用async/await<a class="anchor" href="#使用async-await">·</a></h5><ul><li>输出效果一样，但代码结构看起来清晰得多，几乎跟同步写法一样，十分优雅</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> time1 = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> time2 = <span class="keyword">await</span> <span class="title function_">fn1</span>(time1)</span><br><span class="line">  <span class="keyword">let</span> time3 = <span class="keyword">await</span> <span class="title function_">fn2</span>(time2)</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">await</span> <span class="title function_">fn3</span>(time3)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`result is <span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure><h4 id="2、手动实现一个继发：">2、手动实现一个继发：<a class="anchor" href="#2、手动实现一个继发：">·</a></h4><p>只有<code>getFoo</code>完成以后，才会执行<code>getBar</code>，完全可以让它们同时触发</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> <span class="title function_">getFoo</span>();</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> <span class="title function_">getBar</span>();</span><br></pre></td></tr></table></figure><ul><li><h4 id="for循环实现">for循环实现<a class="anchor" href="#for循环实现">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> doc <span class="keyword">of</span> docs) &#123;</span><br><span class="line">    <span class="keyword">await</span> db.<span class="title function_">post</span>(doc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="reduce实现">reduce实现<a class="anchor" href="#reduce实现">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> docs.<span class="title function_">reduce</span>(<span class="keyword">async</span> (_, doc) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> _;</span><br><span class="line">    <span class="keyword">await</span> db.<span class="title function_">post</span>(doc);</span><br><span class="line">  &#125;, <span class="literal">undefined</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3、并发实现">3、并发实现<a class="anchor" href="#3、并发实现">·</a></h4><p><code>getFoo</code>和<code>getBar</code>都是同时触发，且没有依赖项，这样就会缩短程序的执行时间</p><ul><li><h4 id="Promise-all"><code>Promise.all</code><a class="anchor" href="#Promise-all">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">getFoo</span>(), <span class="title function_">getBar</span>()]);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="keyword">let</span> promises = docs.<span class="title function_">map</span>(<span class="function"><span class="params">doc</span> =&gt;</span> db.<span class="title function_">post</span>(doc));</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">let</span> results = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(promises);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(results);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="赋值操作">赋值操作<a class="anchor" href="#赋值操作">·</a></h4><ul><li><p>getFoo函数本身是非阻塞的，赋值后<strong>不会停在这里等待它的执行结果</strong></p></li><li><p>而await getFoo()在promise有结果之前不会执行赋值操作，async内部代码在promise返回结果之前会阻塞住</p><p>但整个主线程不会阻塞而是会执行async函数后面的同步代码，等promise有了结果且外面的同步代码执行完了就又会回到async函数原来阻塞的地方继续执行</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title function_">getFoo</span>();</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title function_">getBar</span>();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> p1;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> p2;</span><br></pre></td></tr></table></figure></li><li><h4 id="forEach">forEach<a class="anchor" href="#forEach">·</a></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123; <span class="comment">//这里不需要 async</span></span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="keyword">let</span> promises = docs.<span class="title function_">forEach</span>(<span class="keyword">async</span> doc =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> db.<span class="title function_">post</span>(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">let</span> results = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> promise <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    results.<span class="title function_">push</span>(<span class="keyword">await</span> promise);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(results);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h4 id="Map">Map<a class="anchor" href="#Map">·</a></h4><p>虽然map方法的参数是async函数，但它是并发执行，因为只有async函数内部是继发执行，外部不受影响</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">dbFuc</span>(<span class="params">db</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="keyword">let</span> promises = docs.<span class="title function_">map</span>( <span class="keyword">async</span> doc =&gt; db.<span class="title function_">post</span>(doc));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> results = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> promise <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    results.<span class="title function_">push</span>(<span class="keyword">await</span> promise);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(results);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-3、手写promise">2.3、手写promise<a class="anchor" href="#2-3、手写promise">·</a></h2><h4 id="1、Promise的异步实现">1、Promise的异步实现<a class="anchor" href="#1、Promise的异步实现">·</a></h4><h4 id="2、promsie的链式调用">2、promsie的链式调用<a class="anchor" href="#2、promsie的链式调用">·</a></h4><ol><li><strong>首先<code>then</code> 方法必须返回一个 <code>promise</code> 对象(划重点)</strong><ol><li>在<code>then</code>方法中先实例化了一个Promise对象并返回，我们把原来写的代码放到该实例的处理器函数中</li><li>在每个执行函数处使用<code>try..catch</code>语法，try中<code>resolve</code>执行结果，catch中<code>reject</code>异常</li><li>pending状态判断，逻辑也和resolved相似，但是由于此处为了处理异步，做了push操作，所以我们push时在onFulfilled和onRejected回调外面再套一个回调做操作即可</li></ol></li><li><strong>如果<code>then</code>方法中返回的是一个普通值(如Number、String等)就使用此值包装成一个新的Promise对象返回</strong></li><li>如果<code>then</code>方法中没有<code>return</code>语句，就返回一个用Undefined包装的Promise对象</li><li>如果<code>then</code>方法中出现异常，则调用失败态方法(reject)跳转到下一个<code>then</code>的onRejected</li><li><strong>如果<code>then</code>方法没有传入任何回调，则继续向下传递(值穿透)</strong></li><li>如果<code>then</code>方法中返回了一个Promise对象，那就以这个对象为准，返回它的结果</li></ol><h4 id="3、根据上一个then方法的返回值来生成新Promise对象">3、根据上一个<code>then</code>方法的返回值来生成新Promise对象<a class="anchor" href="#3、根据上一个then方法的返回值来生成新Promise对象">·</a></h4><h3 id="1、基本构成">1、基本构成<a class="anchor" href="#1、基本构成">·</a></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Promise</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">  <span class="comment">// 托管构造函数的this指向</span></span><br><span class="line">  <span class="keyword">let</span> _this = <span class="variable language_">this</span></span><br><span class="line">  <span class="comment">// 状态描述 pending resolved rejected</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&quot;pending&quot;</span></span><br><span class="line">  <span class="comment">// 成功结果</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">undefined</span></span><br><span class="line">  <span class="comment">// 失败原因</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">reason</span> = <span class="literal">undefined</span></span><br><span class="line">  <span class="comment">//保存成功回调</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">onResolvedCallbacks</span> = []</span><br><span class="line">  <span class="comment">//保存失败回调</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span> = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 让其处理器函数立即执行</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="title function_">executor</span>(resolve, reject)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">resolve</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断当前态是否为pending，只有pending时可更该状态</span></span><br><span class="line">    <span class="keyword">if</span> (_this.<span class="property">state</span> === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// 更改为成功态</span></span><br><span class="line">      _this.<span class="property">state</span> = <span class="string">&quot;resolved&quot;</span></span><br><span class="line">      <span class="comment">// 保存成功结果</span></span><br><span class="line">      _this.<span class="property">value</span> = value</span><br><span class="line">      <span class="comment">// 遍历执行成功回调</span></span><br><span class="line">      _this.<span class="property">onResolvedCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>(value))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">reject</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断当前态是否为pending，只有pending时可更该状态</span></span><br><span class="line">    <span class="keyword">if</span> (_this.<span class="property">state</span> === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// 更改为失败态</span></span><br><span class="line">      _this.<span class="property">state</span> = <span class="string">&quot;rejected&quot;</span></span><br><span class="line">      <span class="comment">// 保存失败原因</span></span><br><span class="line">      _this.<span class="property">reason</span> = reason</span><br><span class="line">      <span class="comment">// 遍历执行失败回调</span></span><br><span class="line">      _this.<span class="property">onRejectedCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">fn</span> =&gt;</span> <span class="title function_">fn</span>(reason))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、then方法">2、then方法<a class="anchor" href="#2、then方法">·</a></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// then原型方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">then</span> = <span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断参数不为函数时变成普通函数，成功-直接返回接收值 失败-抛出错误</span></span><br><span class="line">  onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&quot;function&quot;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line">  onRejected =</span><br><span class="line">    <span class="keyword">typeof</span> onRejected === <span class="string">&quot;function&quot;</span></span><br><span class="line">      ? onRejected</span><br><span class="line">      : <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个新的Promise实例</span></span><br><span class="line">  <span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 等待态判断，此时异步代码还未走完，回调入数组队列</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&quot;pending&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// 将成功回调push入成功队列</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">onResolvedCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 使用queueMicrotask实现微任务</span></span><br><span class="line">        <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">            <span class="comment">// 处理返回值</span></span><br><span class="line">            <span class="title function_">resolvePromise</span>(promise2, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将失败回调push入失败队列</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 使用queueMicrotask实现微任务</span></span><br><span class="line">        <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">            <span class="comment">// 处理返回值</span></span><br><span class="line">            <span class="title function_">resolvePromise</span>(promise2, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&quot;resolved&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// 使用queueMicrotask实现微任务</span></span><br><span class="line">      <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">          <span class="comment">// 处理返回值</span></span><br><span class="line">          <span class="title function_">resolvePromise</span>(promise2, x, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&quot;rejected&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// 使用queueMicrotask实现微任务</span></span><br><span class="line">      <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">          <span class="comment">// 处理返回值</span></span><br><span class="line">          <span class="title function_">resolvePromise</span>(promise2, x, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> promise2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、解析then返回值与新Promise对象">3、解析then返回值与新Promise对象<a class="anchor" href="#3、解析then返回值与新Promise对象">·</a></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析then返回值与新Promise对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Object</span>&#125; 新的Promise对象，就是我们创建的promise2实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">*</span>&#125; x 上一个then的返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; resolve promise2处理器函数的resolve</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; reject promise2处理器函数的reject</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) &#123;</span><br><span class="line">  <span class="comment">// 解决循环引用报错</span></span><br><span class="line">  <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">    <span class="comment">// reject报错</span></span><br><span class="line">    <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;请避免Promise循环引用&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义状态-防止多次调用</span></span><br><span class="line">  <span class="keyword">let</span> called</span><br><span class="line">  <span class="comment">// x不是null 且x是对象或函数</span></span><br><span class="line">  <span class="keyword">if</span> (x != <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> x === <span class="string">&quot;function&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 拿到x的then方法</span></span><br><span class="line">      <span class="keyword">let</span> then = x.<span class="property">then</span></span><br><span class="line">      <span class="comment">// 如果then是函数，就默认是promise</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// 执行then 使用call传递this 第一个参数是this 后面是成功的回调 和 失败的回调</span></span><br><span class="line">        then.<span class="title function_">call</span>(</span><br><span class="line">          x,</span><br><span class="line">          <span class="function"><span class="params">y</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 成功和失败只能调用一个</span></span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">            called = <span class="literal">true</span></span><br><span class="line">            <span class="comment">// 防止用户在resolve的时候传入Promise，递归调用</span></span><br><span class="line">            <span class="title function_">resolvePromise</span>(promise2, y, resolve, reject)</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 成功和失败只能调用一个</span></span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">            called = <span class="literal">true</span></span><br><span class="line">            <span class="title function_">reject</span>(err)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(x)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">      called = <span class="literal">true</span></span><br><span class="line">      <span class="title function_">reject</span>(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、catch、resolve、reject方法">4、catch、resolve、reject方法<a class="anchor" href="#4、catch、resolve、reject方法">·</a></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// catch原型方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">catch</span> = <span class="keyword">function</span>(<span class="params">onRejected</span>) &#123;</span><br><span class="line">  <span class="comment">// 直接执行then方法，onFulfilled为null，传入onRejected</span></span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(<span class="literal">null</span>, onRejected)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// resolve方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">resolve</span> = <span class="keyword">function</span>(<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="comment">// 直接抛出一个成功状态的Promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(val)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reject方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">reject</span> = <span class="keyword">function</span>(<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="comment">// 直接抛出一个拒绝状态的Promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(val)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、all方法">5、all方法<a class="anchor" href="#5、all方法">·</a></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// all方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">all</span> = <span class="keyword">function</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="comment">// 只有一个目的 获取到所有的promise，都执行then，把结果放到数组，一起返回</span></span><br><span class="line">  <span class="comment">// 用于存放每次执行后返回结果</span></span><br><span class="line">  <span class="keyword">let</span> results = []</span><br><span class="line">  <span class="keyword">let</span> promiseCount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">let</span> promisesLength = promises.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>;i&lt; promises.<span class="property">length</span>;i++) &#123; <span class="comment">// 使用let保证promise顺序执行</span></span><br><span class="line">      <span class="comment">// Promise.resolve：因为数组中的可能不是promise实例，没有then方法</span></span><br><span class="line">			<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(promises[i]).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          results[i] = res;</span><br><span class="line">          promiseCount++;</span><br><span class="line">          <span class="comment">// 当所有函数都正确执行了，resolve输出所有返回结果</span></span><br><span class="line">          <span class="keyword">if</span> (promiseCount === promisesLength)  <span class="title function_">resolve</span>(results);</span><br><span class="line">      	&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">reject</span>(err);</span><br><span class="line">        &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line"> 	<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">resolve</span>(<span class="number">3</span>)</span><br><span class="line">  &#125;,<span class="number">1000</span>)&#125;)</span><br><span class="line"> );</span><br><span class="line"><span class="keyword">var</span> p2 =<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> p3 =<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1,p2,p3]);</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">e</span>=&gt;</span>&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(e)&#125;);</span><br></pre></td></tr></table></figure><h3 id="6、race方法">6、race方法<a class="anchor" href="#6、race方法">·</a></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// race方法</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="property">race</span> = <span class="keyword">function</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="comment">// return一个Promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历执行promises</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="comment">// then只要接收到状态改变，直接抛出</span></span><br><span class="line">      promises[i].<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4、手写Promise-all、allsettled">2.4、手写Promise.all、allsettled<a class="anchor" href="#2-4、手写Promise-all、allsettled">·</a></h2><h3 id="1、使用all：">1、使用all：<a class="anchor" href="#1、使用all：">·</a></h3><ul><li><p>iterable类型：代表可迭代对象，<code>Array</code>、<code>Map</code>和<code>Set</code>都属于<code>iterable</code>类型</p></li><li><p>应用场景：有一个接口，需要其他两个或多个接口返回的数据作为参数时</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Promise.all(iterable)</span><br></pre></td></tr></table></figure></li><li><p>当需要处理多个Promise并行时，大多数情况下Promise.all用起来是非常顺手的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">delay</span> = n =&gt; <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, n));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  <span class="title function_">delay</span>(<span class="number">100</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="number">1</span>),</span><br><span class="line">  <span class="title function_">delay</span>(<span class="number">200</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="number">2</span>),</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(promises).<span class="title function_">then</span>(<span class="function"><span class="params">values</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(values))</span><br><span class="line"><span class="comment">// 最终输出： [1, 2]</span></span><br></pre></td></tr></table></figure></li><li><p>可是，是一旦有一个promise出现了异常，被reject了，情况就会变的麻烦。</p><p>问题1：任意一个 promise 被 reject ，Promise.all 就会立即被 reject ，其他执行成功的Promise的消息都丢失了</p><p>问题2：大多数场景中，我们期望传入的这组 promise 无论执行失败或成功，都能获取每个 promise 的执行结果</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">delay</span> = n =&gt; <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, n));</span><br><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  <span class="title function_">delay</span>(<span class="number">100</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="number">1</span>),</span><br><span class="line">  <span class="title function_">delay</span>(<span class="number">200</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="number">2</span>),</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>)</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(promises).<span class="title function_">then</span>(<span class="function"><span class="params">values</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(values))</span><br><span class="line"><span class="comment">// 最终输出： Uncaught (in promise) 3</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(promises)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">values</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(values))</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(err))  <span class="comment">// 加入catch语句后，最终输出：3</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2、手写Promise-all">2、手写Promise.all<a class="anchor" href="#2、手写Promise-all">·</a></h3><ul><li><p>将多个Promise 实例<strong>包装成一个新的 Promise实例</strong>，参数为一组 <strong>Promise 实例组成的数组</strong></p></li><li><p>只有所有的 promise <code>都成功才成功</code>, 只要有一 个失败了就直接失败</p></li><li><p>promsie.all的痛点：一旦有一个promise出现了异常，被reject了，情况就会变的麻烦。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// all方法: 只有一个目的 获取到所有的promise，都执行then，把结果放到数组，一起返回</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">PromiseAll</span> = promises =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!promises.<span class="property">length</span>) <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>([]);</span><br><span class="line">	<span class="keyword">const</span> newPromises = promises.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item <span class="keyword">instanceof</span> <span class="title class_">Promise</span> ? item :  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(item);</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> results = []; <span class="comment">// 用于存放每次执行后返回结果</span></span><br><span class="line">  <span class="keyword">let</span> promiseCount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> promiseLen = newPromises.<span class="property">length</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; promiseLen; i++) &#123; <span class="comment">// 使用let保证promise顺序执行</span></span><br><span class="line">      <span class="comment">// Promise.resolve：因为数组中的可能不是promise实例，没有then方法</span></span><br><span class="line">				newPromises[i].<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        	results[i] = &#123;</span><br><span class="line">            <span class="attr">status</span>: <span class="string">&#x27;fulfilled&#x27;</span>,</span><br><span class="line">            value</span><br><span class="line">          &#125;</span><br><span class="line">          promiseCount++;</span><br><span class="line">          <span class="comment">// 当所有函数都正确执行了，resolve输出所有返回结果</span></span><br><span class="line">          <span class="keyword">if</span> (promiseCount === promiseLen)  <span class="title function_">resolve</span>(results);</span><br><span class="line">      	&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">           results[i] = &#123;</span><br><span class="line">              <span class="attr">status</span>: <span class="string">&#x27;rejected&#x27;</span>,</span><br><span class="line">              err</span><br><span class="line">     				&#125;</span><br><span class="line">    				<span class="title function_">reject</span>(results);</span><br><span class="line">        &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">delay</span> = n =&gt; <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, n));</span><br><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  <span class="title function_">delay</span>(<span class="number">100</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="number">1</span>),</span><br><span class="line">  <span class="title function_">delay</span>(<span class="number">200</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="number">2</span>),</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>)</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"><span class="title class_">PromiseAll</span>(promises).<span class="title function_">then</span>(<span class="function"><span class="params">values</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(values))</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err+<span class="string">&#x27; 捕获的错误&#x27;</span>))<span class="comment">//不然会报错走不下去</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3、使用allsettled">3、使用allsettled<a class="anchor" href="#3、使用allsettled">·</a></h3><ul><li><p>返回的新 Promise 实例，一旦结束，状态总是 fulfilled，不会变成 rejected</p></li><li><p>使用场景：</p><p>不关心异步操作的结果，只关心这些操作有没有结束时，这个方法会比较有用。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  <span class="title function_">delay</span>(<span class="number">100</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="number">1</span>),</span><br><span class="line">  <span class="title function_">delay</span>(<span class="number">200</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="number">2</span>),</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">3</span>)   <span class="comment">//拒绝</span></span><br><span class="line">  ]</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">allSettled</span>(promises).<span class="title function_">then</span>(<span class="function"><span class="params">values</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(values))</span><br><span class="line"><span class="comment">// 最终输出： </span></span><br><span class="line"><span class="comment">//    [</span></span><br><span class="line"><span class="comment">//      &#123;status: &quot;fulfilled&quot;, value: 1&#125;,</span></span><br><span class="line"><span class="comment">//      &#123;status: &quot;fulfilled&quot;, value: 2&#125;,</span></span><br><span class="line"><span class="comment">//      &#123;status: &quot;rejected&quot;, value: 3&#125;,</span></span><br><span class="line"><span class="comment">//    ]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4、手写allsettled">4、手写allsettled<a class="anchor" href="#4、手写allsettled">·</a></h3><ul><li><p>即使是遇到rejec也会等待所有的promise到最后。所以我们只需要用一个array记录各个promise的fulfill或者reject结果即可</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">PromiseAllSettled</span> = <span class="keyword">function</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!promises.<span class="property">length</span>) <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>([]);</span><br><span class="line">	<span class="keyword">const</span> newPromises = promises.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item <span class="keyword">instanceof</span> <span class="title class_">Promise</span> ? item :  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(item);</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> results = []; <span class="comment">// 用于存放每次执行后返回结果</span></span><br><span class="line">  <span class="keyword">let</span> promiseCount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> promiseLen = newPromises.<span class="property">length</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; promiseLen; i++) &#123; <span class="comment">// 使用let保证promise顺序执行</span></span><br><span class="line">      <span class="comment">// Promise.resolve：因为数组中的可能不是promise实例，没有then方法</span></span><br><span class="line">				newPromises[i].<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        	results[i] = &#123;</span><br><span class="line">            <span class="attr">status</span>: <span class="string">&#x27;fulfilled&#x27;</span>,</span><br><span class="line">            value</span><br><span class="line">          &#125;</span><br><span class="line">          promiseCount++;</span><br><span class="line">          <span class="keyword">if</span> (promiseCount === promiseLen)  <span class="title function_">resolve</span>(results);</span><br><span class="line">      	&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">           results[i] = &#123;</span><br><span class="line">              <span class="attr">status</span>: <span class="string">&#x27;rejected&#x27;</span>,</span><br><span class="line">              err</span><br><span class="line">     				&#125;</span><br><span class="line">           promiseCount++;</span><br><span class="line">         	 <span class="keyword">if</span> (promiseCount === promiseLen)  <span class="title function_">resolve</span>(results);</span><br><span class="line">        &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5、race实现">5、race实现<a class="anchor" href="#5、race实现">·</a></h3><ul><li><p>最早改变状态）resolve或reject时，就改变自身的状态，并执行响应的回调。</p></li><li><p>跟all同样对于错误的不能处理。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">PromiseRace</span> = <span class="keyword">function</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!promises.<span class="property">length</span>) <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>([]);</span><br><span class="line">	<span class="keyword">const</span> newPromises = promises.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> item <span class="keyword">instanceof</span> <span class="title class_">Promise</span> ? item :  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(item);</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> promiseLen = newPromises.<span class="property">length</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; promiseLen; i++) &#123;</span><br><span class="line">				newPromises[i].<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(&#123;</span><br><span class="line">            <span class="attr">status</span>: <span class="string">&#x27;fulfilled&#x27;</span>,</span><br><span class="line">            value</span><br><span class="line">          &#125;);</span><br><span class="line">      	&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">reject</span>(&#123;</span><br><span class="line">              <span class="attr">status</span>: <span class="string">&#x27;rejected&#x27;</span>,</span><br><span class="line">              err</span><br><span class="line">     			&#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5、实现promisify化">5、实现promisify化<a class="anchor" href="#5、实现promisify化">·</a></h2><h3 id="1、概念">1、概念<a class="anchor" href="#1、概念">·</a></h3><ul><li><p><code>promisify</code>是node的utils模块中的一个函数</p></li><li><p>作用：<strong>将一种函数</strong>（最后一个参数是回调函数的函数，且回调函数中有两个参数：<code>error</code> 和 <code>data</code>）<strong>转换为promise函数</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用前</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./index.js&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">if</span>(!err) &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>())</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 使用promisify后</span></span><br><span class="line"><span class="keyword">const</span> readFile = <span class="title function_">promisify</span>(fs.<span class="property">readFile</span>)</span><br><span class="line"><span class="title function_">readFile</span>(<span class="string">&#x27;./index.js&#x27;</span>)</span><br><span class="line">   .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>())</span><br><span class="line">   &#125;)</span><br><span class="line">   .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error:&#x27;</span>, err)</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="2、实现">2、实现<a class="anchor" href="#2、实现">·</a></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> newFn = <span class="title function_">promisify</span>(fn)</span><br><span class="line"><span class="title function_">newFn</span>(a) <span class="comment">// 会执行Promise参数方法</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">promisify</span> = (<span class="params">func</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 除了调用时的传参，还需要提供一个callback函数来供异步方法调用</span></span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">callback</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="title function_">reject</span>(err);</span><br><span class="line">           <span class="keyword">return</span> <span class="title function_">resolve</span>(res);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      args.<span class="title function_">push</span>(<span class="title function_">callback</span>());</span><br><span class="line">      func.<span class="title function_">apply</span>(ctx, args);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>JS的异步解决方案</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://www.nesxc.com/post/hexocc.html">https://www.nesxc.com/post/hexocc.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>飞儿</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2021-12-11</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2023-01-17</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post_share"><div class="social-share" data-image="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTfnIl0f3oUJLgGFb7Qgi97y1hY9uIQsHizXQ&amp;usqp=CAU" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="/" media="print" onload='this.media="all"'><script src="/" defer></script></div></div><div id="wpac-rating"></div><script>wpac_init = window.wpac_init || [];
wpac_init.push({widget: 'Rating', id: 33234});
(function() {
  if ('WIDGETPACK_LOADED' in window) return;
  WIDGETPACK_LOADED = true;
  var mc = document.createElement('script');
  mc.type = 'text/javascript';
  mc.async = true;
  //- mc.src = '//embed.widgetpack.com/widget.js';
  var s = document.getElementsByTagName('script')[0];
  s?.parentNode?.insertBefore(mc, s?.nextSibling);
})();</script><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/656350506.html"><img class="prev-cover" src="https://mynightwish.oss-cn-beijing.aliyuncs.com/CSS/浏览器异步.webp" onerror='onerror=null,src="https://mynightwish.oss-cn-beijing.aliyuncs.com/staticResource/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JS的EventLoop</div></div></a></div><div class="next-post pull-right"><a href="/posts/prototype.html"><img class="next-cover" src="https://images.unsplash.com/photo-1616362657885-73baafe81a3e?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1332&amp;q=80" onerror='onerror=null,src="https://mynightwish.oss-cn-beijing.aliyuncs.com/staticResource/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JS的继承</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">异步解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81JS%E7%9A%84%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1"><span class="toc-text">1、JS的异步任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%87%A0%E7%A7%8D%E5%BC%82%E6%AD%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">2、几种异步解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E3%80%81%E6%96%B9%E5%BC%8F1%EF%BC%9A%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-text">3.1、方式1：回调函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E3%80%81%E6%96%B9%E5%BC%8F2%EF%BC%9A%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC"><span class="toc-text">3.2、方式2：事件监听</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E3%80%81%E6%96%B9%E5%BC%8F3%EF%BC%9A%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85"><span class="toc-text">3.3、方式3：发布订阅</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E7%94%A8class%E5%AE%9E%E7%8E%B0"><span class="toc-text">1、用class实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E4%BD%BF%E7%94%A8"><span class="toc-text">2、使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4%E3%80%81%E6%96%B9%E5%BC%8F4%EF%BC%9Apromise"><span class="toc-text">3.4、方式4：promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5%E3%80%81Generator"><span class="toc-text">3.5、Generator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6%E3%80%81async-await"><span class="toc-text">3.6、async await</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E3%80%81Promise%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98"><span class="toc-text">2.1、Promise概念及关键问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">1、是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E8%A1%A8%E8%BE%BE"><span class="toc-text">抽象表达:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E8%A1%A8%E8%BE%BE"><span class="toc-text">具体表达:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%812%E4%B8%AA%E7%89%B9%E7%82%B9"><span class="toc-text">2、2个特点:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BC%98-%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">3、优&#x2F;缺点：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1%E3%80%81%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-text">3.1、优点：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A5%E5%BE%80%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">以往异步编程模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#promise"><span class="toc-text">promise</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2%E3%80%81%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">3.2、缺点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81onRejected%E5%92%8Ccatch%E5%8C%BA%E5%88%AB"><span class="toc-text">4、onRejected和catch区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81then%E4%B8%AD%E6%8A%9B%E9%94%99%E6%9C%AA%E5%A4%84%E7%90%86"><span class="toc-text">5、then中抛错未处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E5%9B%BE%EF%BC%9A"><span class="toc-text">流程图：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83%E4%B8%AD%E6%8A%9B%E9%94%99catch%E6%8D%95%E6%8D%89%E4%B8%8D%E5%88%B0"><span class="toc-text">6、异步回调中抛错catch捕捉不到</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E4%B8%AD%E6%96%AD-promise-%E9%93%BE"><span class="toc-text">7、中断 promise 链?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E4%B8%80%E4%B8%AA-promise-%E6%8C%87%E5%AE%9A%E5%A4%9A%E4%B8%AA%E6%88%90%E5%8A%9F-%E5%A4%B1%E8%B4%A5%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0-%E9%83%BD%E4%BC%9A%E8%B0%83%E7%94%A8%E5%90%97"><span class="toc-text">8、一个 promise 指定多个成功&#x2F;失败回调函数, 都会调用吗?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E6%94%B9%E5%8F%98-promise-%E7%8A%B6%E6%80%81%E5%92%8C%E6%8C%87%E5%AE%9A%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E8%B0%81%E5%85%88%E8%B0%81%E5%90%8E"><span class="toc-text">9、改变 promise 状态和指定回调函数谁先谁后?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%85%88%E6%8C%87%E5%AE%9A%E5%9B%9E%E8%B0%83%E5%86%8D%E6%94%B9%E5%8F%98%E7%8A%B6%E6%80%81"><span class="toc-text">1、先指定回调再改变状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%85%88%E6%94%B9%E7%8A%B6%E6%80%81%E5%86%8D%E6%8C%87%E5%AE%9A%E5%9B%9E%E8%B0%83"><span class="toc-text">2、先改状态再指定回调</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%E2%80%93%E7%BB%93%E5%90%88%E6%BA%90%E7%A0%81"><span class="toc-text">3、个人理解–结合源码</span></a></li></ol></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E3%80%81Promise%E7%94%A8%E6%B3%95"><span class="toc-text">2.2、Promise用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Promise-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-Promise-excutor"><span class="toc-text">1- Promise 构造函数: Promise (excutor) {}</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-text">1、参数传递问题：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81resolve%E6%88%96reject%E5%AF%B9%E6%89%A7%E8%A1%8C%E5%99%A8%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E5%BD%B1%E5%93%8D"><span class="toc-text">2、resolve或reject对执行器函数的执行影响</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81return%E7%9A%84%E5%BD%B1%E5%93%8D%EF%BC%9A"><span class="toc-text">3、return的影响：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95then"><span class="toc-text">2-原型方法then</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84-promise-%E5%AF%B9%E8%B1%A1"><span class="toc-text">1、返回值：返回一个新的 promise 对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9Cpromise-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%8A%B6%E6%80%81-%E9%87%8D%E8%A6%815%E6%9D%A1"><span class="toc-text">2、返回结果promise 对象的状态 重要5条</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95catch"><span class="toc-text">3-原型方法catch</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9A%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84promise%E5%AE%9E%E4%BE%8B%EF%BC%8C%E5%9B%A0%E6%AD%A4%E5%90%8E%E9%9D%A2%E8%BF%98%E5%8F%AF%E4%BB%A5%E6%8E%A5%E7%9D%80%E8%B0%83%E7%94%A8then-%E6%96%B9%E6%B3%95"><span class="toc-text">1、返回值：返回一个新的promise实例，因此后面还可以接着调用then()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81catch%E5%8F%AF%E4%BB%A5%E6%8D%95%E8%8E%B7%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">2、catch可以捕获什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-%E5%86%85%E9%83%A8%E7%9A%84%E9%94%99%E8%AF%AF"><span class="toc-text">Promise 内部的错误</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#then-%E6%96%B9%E6%B3%95%E4%B8%AD%E6%8A%9B%E5%87%BA%E9%94%99%E8%AF%AF"><span class="toc-text">then()方法中抛出错误</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#promise%E5%BC%82%E5%B8%B8%E7%A9%BF%E9%80%8F"><span class="toc-text">promise异常穿透</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95finally"><span class="toc-text">4-原型方法finally</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95Promise-resolve"><span class="toc-text">1-静态方法Promise.resolve :</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E4%BC%A0%E5%8F%82%E6%83%85%E5%86%B54%E7%A7%8D"><span class="toc-text">1、传参情况4种</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-text">2、执行顺序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95Promise-reject"><span class="toc-text">2-静态方法Promise.reject :</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95Promise-all"><span class="toc-text">3-静态方法Promise.all :</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95Promise-race"><span class="toc-text">4-静态方法Promise.race :</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Generaor"><span class="toc-text">3、Generaor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%8D%8F%E7%A8%8B"><span class="toc-text">1、协程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%EF%BC%9A"><span class="toc-text">举例文件读取：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Generator-%E5%87%BD%E6%95%B0"><span class="toc-text">2、Generator 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F%E4%B8%BE%E4%BE%8B"><span class="toc-text">运行方式举例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%BE%E4%BE%8B"><span class="toc-text">文件读取举例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85co%E5%BA%93%E5%90%8E%EF%BC%9A"><span class="toc-text">安装co库后：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E9%97%AE%E9%A2%98"><span class="toc-text">回调地狱问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">3、优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-text">缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81async%E3%80%81await"><span class="toc-text">4、async、await</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0%E3%80%81async-await%E5%B8%A6%E6%9D%A5%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-text">0、async&#x2F;await带来了什么</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E4%BC%98%E7%82%B9"><span class="toc-text">1、优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%BC%BA%E7%82%B9"><span class="toc-text">2、缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81async%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">1、async返回值</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%BApromise%EF%BC%8C%E7%8A%B6%E6%80%81%E5%92%8C%E5%80%BC%E5%8F%96%E5%86%B3%E4%BA%8E%E8%BF%99%E4%B8%AApromise"><span class="toc-text">返回值为promise，状态和值取决于这个promise</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E9%9D%9Epromise%EF%BC%8C%E5%88%99%E4%BC%9A%E8%A2%AB%E5%8C%85%E8%A3%85%E4%B8%BA%E4%B8%80%E4%B8%AA%E7%AB%8B%E5%8D%B3resolve%E7%9A%84Promise%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%80%BC%E4%B8%BA%E8%BF%94%E5%9B%9E%E7%9A%84%E9%9D%9Epromise%E5%80%BC"><span class="toc-text">函数返回非promise，则会被包装为一个立即resolve的Promise对象，值为返回的非promise值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%BAundefined-%E7%8A%B6%E6%80%81%E6%88%90%E5%8A%9F-%E5%80%BC%E4%B8%BAundefined"><span class="toc-text">函数返回值为undefined.状态成功,值为undefined</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BD%93%E5%86%85%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-text">函数体内抛出异常</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81await"><span class="toc-text">2、await</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81await%E5%9C%A8%E7%AD%89%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">1、await在等什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88await-%E5%8F%AA%E8%83%BD%E5%9C%A8-async-%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8"><span class="toc-text">2、为什么await 只能在 async 函数中使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81await%E5%90%8E%E9%9D%A2%E4%BB%A3%E7%A0%81%E6%98%AF%E5%BE%AE%E4%BB%BB%E5%8A%A1microtask"><span class="toc-text">3、await后面代码是微任务microtask</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E7%9A%84%E4%BE%8B%E5%AD%90%E9%87%8D%E5%86%99"><span class="toc-text">4、读取文件的例子重写</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8"><span class="toc-text">3、处理异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%AF%BC%E8%87%B4%E4%B8%AD%E6%96%AD"><span class="toc-text">错误导致中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#catch"><span class="toc-text">catch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#try%E2%80%A6catch"><span class="toc-text">try…catch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81async-await%E7%BB%A7%E3%80%81%E5%B9%B6%E5%8F%91%E3%80%81promise-all"><span class="toc-text">4、async&#x2F;await继、并发、promise.all</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E7%BB%A7%E5%8F%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">1、继发及其应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Promise"><span class="toc-text">使用Promise:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8async-await"><span class="toc-text">使用async&#x2F;await</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%BB%A7%E5%8F%91%EF%BC%9A"><span class="toc-text">2、手动实现一个继发：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for%E5%BE%AA%E7%8E%AF%E5%AE%9E%E7%8E%B0"><span class="toc-text">for循环实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reduce%E5%AE%9E%E7%8E%B0"><span class="toc-text">reduce实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%9E%E7%8E%B0"><span class="toc-text">3、并发实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-all"><span class="toc-text">Promise.all</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="toc-text">赋值操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#forEach"><span class="toc-text">forEach</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Map"><span class="toc-text">Map</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3%E3%80%81%E6%89%8B%E5%86%99promise"><span class="toc-text">2.3、手写promise</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81Promise%E7%9A%84%E5%BC%82%E6%AD%A5%E5%AE%9E%E7%8E%B0"><span class="toc-text">1、Promise的异步实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81promsie%E7%9A%84%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8"><span class="toc-text">2、promsie的链式调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%A0%B9%E6%8D%AE%E4%B8%8A%E4%B8%80%E4%B8%AAthen%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E6%9D%A5%E7%94%9F%E6%88%90%E6%96%B0Promise%E5%AF%B9%E8%B1%A1"><span class="toc-text">3、根据上一个then方法的返回值来生成新Promise对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%9E%84%E6%88%90"><span class="toc-text">1、基本构成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81then%E6%96%B9%E6%B3%95"><span class="toc-text">2、then方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E8%A7%A3%E6%9E%90then%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%8E%E6%96%B0Promise%E5%AF%B9%E8%B1%A1"><span class="toc-text">3、解析then返回值与新Promise对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81catch%E3%80%81resolve%E3%80%81reject%E6%96%B9%E6%B3%95"><span class="toc-text">4、catch、resolve、reject方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81all%E6%96%B9%E6%B3%95"><span class="toc-text">5、all方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81race%E6%96%B9%E6%B3%95"><span class="toc-text">6、race方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4%E3%80%81%E6%89%8B%E5%86%99Promise-all%E3%80%81allsettled"><span class="toc-text">2.4、手写Promise.all、allsettled</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BD%BF%E7%94%A8all%EF%BC%9A"><span class="toc-text">1、使用all：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%89%8B%E5%86%99Promise-all"><span class="toc-text">2、手写Promise.all</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BD%BF%E7%94%A8allsettled"><span class="toc-text">3、使用allsettled</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%89%8B%E5%86%99allsettled"><span class="toc-text">4、手写allsettled</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81race%E5%AE%9E%E7%8E%B0"><span class="toc-text">5、race实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%AE%9E%E7%8E%B0promisify%E5%8C%96"><span class="toc-text">5、实现promisify化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%A6%82%E5%BF%B5"><span class="toc-text">1、概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">2、实现</span></a></li></ol></li></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By 飞儿</div><div id="running-time"></div><div class="footer_custom_text"><p><a style="margin-inline:5px" target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为 Hexo" alt="HEXO"></a><a style="margin-inline:5px" target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用 Butterfly" alt="Butterfly"></a><a style="margin-inline:5px" target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用 Jsdelivr 为静态资源提供CDN加速" alt="Jsdelivr"></a><a style="margin-inline:5px" target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由 GitHub 托管" alt="GitHub"></a><a style="margin-inline:5px" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" alt="img" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="to_comment" type="button" title="直达评论" onclick="FixedCommentBtn()"><i class="fas fa-comments"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight,500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{const t=document.getElementById("twikoo-count"),o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo-hexo-vert.vercel.app/",region:""},null))},e=()=>{twikoo.getCommentsCount({envId:"https://twikoo-hexo-vert.vercel.app/",region:"",urls:[window.location.pathname],includeReply:!1}).then((function(o){t.innerText=o[0].count})).catch((function(t){console.error(t)}))},n=(n=!1)=>{"object"==typeof twikoo?(o(),n&&t&&setTimeout(e,0)):getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(()=>{o(),n&&t&&setTimeout(e,0)})};btf.loadComment(document.getElementById("twikoo-wrap"),n)})()</script></div><script defer data-pjax src="/js/nav.js"></script><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script defer src="/js/cursor.js"></script><script async src="//at.alicdn.com/t/c/font_3859043_rw1ayonelb.js"></script><script defer data-pjax src="/js/meihua.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script defer data-pjax src="/js/bottomTime.js"></script><div id="live3d" class="live3d" style="position:fixed;left:-110px;bottom:30px;z-index:98"><canvas id="live2dm" class="live3d" style="max-width:500px;max-height:437.5px"></canvas></div><script defer data-pjax src="https://cdn.jsdelivr.net/npm/hexo-beautiful-page@latest/lib/asyncmodel.min.js"></script><script defer data-pjax src="/js/sun_moon.js" async></script><script defer src="https://cdn.jsdelivr.net/npm/echarts@4.9.0/dist/echarts.min.js"></script><script defer data-pjax src="/js/emoji.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors=["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(window.removeEventListener("scroll",window.tocScrollFn),window.removeEventListener("scroll",scrollCollect),"object"==typeof preloader&&preloader.initLoading(),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode")})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach(e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach(e=>t.setAttribute(e.name,e.value)),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)}),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof chatBtnFn&&chatBtnFn(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll(),"object"==typeof preloader&&preloader.endLoading()})),document.addEventListener("pjax:error",e=>{404===e.request.status&&pjax.loadUrl("/404.html")})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script data-pjax>if(document.getElementById("recent-posts")&&"/"===location.pathname){var parent=document.getElementById("recent-posts"),child='<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://mynightwish.online/categories/1-1-CSS/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🌰 CSS<br>(17)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://mynightwish.online/categories/1-2-JS/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🥑 JS、ES<br>(29)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://mynightwish.online/categories/1-3-Ajax/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🥝 Ajax、Axios<br>(3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://mynightwish.online/categories/1-4-框架/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍡 React、Vue<br>(15)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://mynightwish.online/categories/2-1-组件库/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍉 组件库开发<br>(2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://mynightwish.online/categories/2-2-基建/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍹 项目基建<br>(5)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://mynightwish.online/categories/2-3-实现Tricks/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💫 积累功能<br>(4)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://mynightwish.online/categories/2-4-项目/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🔮 项目总结<br>(12)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://mynightwish.online/categories/3-1-记录/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">👻 碎碎念~<br>(3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://mynightwish.online/categories/3-2-浏览器/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 浏览器渲染<br>(8)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://mynightwish.online/categories/3-3-基础/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🧊 网络<br>(10)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://mynightwish.online/categories/3-4-Tool/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍤 工具、脚本<br>(1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://mynightwish.online/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';console.log("已挂载magnet"),parent.insertAdjacentHTML("afterbegin",child)}</script><style>#catalog_magnet{flex-wrap:wrap;display:flex;width:100%;justify-content:space-between;padding:10px 10px 0 10px;align-content:flex-start}.magnet_item{flex-basis:calc(25% - 5px);background:#f2f2f2;margin-bottom:10px;border-radius:8px;transition:all .2s ease-in-out}.magnet_item:hover{background:#b30070}.magnet_link_more{color:#555}.magnet_link{color:#000}.magnet_link:hover{color:#fff}@media screen and (max-width:600px){.magnet_item{flex-basis:100%}}.magnet_link_context{display:flex;padding:10px;font-size:16px;transition:all .2s ease-in-out}.magnet_link_context:hover{padding:10px 20px}</style><style></style><script data-pjax>function butterfly_swiper_injector_config(){var s=document.getElementById("recent-posts");console.log("已挂载butterfly_swiper"),s.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2621268747.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://mynightwish.oss-cn-beijing.aliyuncs.com/React/react-virtualDom.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2021-12-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2621268747.html&quot;);" href="javascript:void(0);" alt="">React的虚拟DOM</a><div class="blog-slider__text">兄弟篇React的虚拟DOM，包括了栈调和</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2621268747.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/ReactHooks.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://mynightwish.oss-cn-beijing.aliyuncs.com/React/hook1.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2021-12-11</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/ReactHooks.html&quot;);" href="javascript:void(0);" alt="">React-Hook的出现</a><div class="blog-slider__text">为何Hooks是React的未来</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/ReactHooks.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/656350506.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://mynightwish.oss-cn-beijing.aliyuncs.com/CSS/浏览器异步.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2021-12-11</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/656350506.html&quot;);" href="javascript:void(0);" alt="">JS的EventLoop</a><div class="blog-slider__text">异步与同步、宏任务、微任务</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/656350506.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/3384747987.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTfnIl0f3oUJLgGFb7Qgi97y1hY9uIQsHizXQ&amp;usqp=CAU" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2021-12-11</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/3384747987.html&quot;);" href="javascript:void(0);" alt="">JS的异步解决方案</a><div class="blog-slider__text">前端异步之路</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/3384747987.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>')}for(var elist="undefined".split(","),cpage=location.pathname,epage="/",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_swiper_injector_config()</script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script async>window.onload=function(){var e=document.createElement("script"),t=document.getElementsByTagName("script")[0];e.type="text/javascript",e.async=!0,e.src="/sw-register.js?v="+Date.now(),t.parentNode.insertBefore(e,t)}</script></body></html>